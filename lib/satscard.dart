import 'dart:typed_data';

import 'package:cktap_protocol/cktap_protocol.dart';
import 'package:cktap_protocol/cktapcard.dart';
import 'package:cktap_protocol/src/cktap_implementation.dart';
import 'package:cktap_protocol/src/native/bindings.dart';
import 'package:cktap_protocol/src/native/translations.dart';
import 'package:cktap_protocol/transport.dart';

class Satscard extends CKTapCard {
  final int activeSlotIndex;
  final int numSlots;
  final bool hasUnusedSlots;
  final bool isUsedUp;

  static Future<Satscard> fromTransport(Transport transport) =>
      CKTapProtocol.readCard(transport, type: CardType.satscard)
          .then((card) => card.toSatscard()!);

  /// Checks the certificate of the Satscard to ensure it's an authentic card.
  /// [isCertsChecked] will be updated based on the result
  Future<void> certificateCheck(Transport transport) =>
      CKTapImplementation.instance
          .satscardCertificateCheck(transport, handle)
          .then((value) => isCertsChecked = value);

  /// Constructs and returns the active slot of the Satscard, if one exists. Any
  /// Satscard which hasn't been fully used up will have an active slot, however
  /// if [isUsedUp] is true then this will fail
  Future<Slot> getActiveSlot() =>
      CKTapImplementation.instance.satscardGetActiveSlot(handle);

  /// Requests the given slot from the Satscard. If the [spendCode] is provided
  /// then the private key will also be revealed for [SlotStatus.unsealed] slots
  Future<Slot> getSlot(Transport transport, int slot,
          {String spendCode = ""}) =>
      CKTapImplementation.instance
          .satscardGetSlot(transport, slot, spendCode, handle);

  /// Requests every slot from the Satscard. If the [spendCode] is provided then
  /// the private keys will also be available for [SlotStatus.unsealed] slots
  Future<List<Slot>> listSlots(Transport transport,
          {String spendCode = "", int limit = 10}) =>
      CKTapImplementation.instance
          .satscardListSlots(transport, spendCode, limit, handle);

  /// Attempts to initialize the next slot of the Satscard, revealing a new
  /// public key and making the next slot active. If [isUsedUp] this will fail.
  /// [chainCode] must either be empty (and will be generated by the library) or
  /// a 64-character (32-byte) hex string. [spendCode] must be a 6-digit numeric
  /// code
  Future<Slot> newSlot(Transport transport, String spendCode,
          {String chainCode = ""}) =>
      CKTapImplementation.instance
          .satscardNew(transport, spendCode, chainCode, handle);

  /// Attempts to unseal the current slot revealing the private key for the
  /// active slot. If [isUsedUp] is true this will fail. [spendCode] must be a
  /// 6-digit numeric code
  Future<Slot> unseal(Transport transport, String spendCode) =>
      CKTapImplementation.instance.satscardUnseal(transport, spendCode, handle);

  Satscard(SatscardConstructorParams params)
      : activeSlotIndex = params.activeSlotIndex,
        numSlots = params.numSlots,
        hasUnusedSlots = params.hasUnusedSlots > 0,
        isUsedUp = params.isUsedUp > 0,
        super(params.base);
}

class Slot {
  final int _owner;
  final int index;
  final SlotStatus status;
  final String address;

  // Requires the CVC to acquire
  final Uint8List privkey;
  final Uint8List pubkey;
  final Uint8List masterPK;
  final Uint8List chainCode;

  Future<String> toWif() =>
      CKTapImplementation.instance.slotToWif(_owner, index);

  Slot(SlotConstructorParams params)
      : _owner = params.satscardHandle,
        index = params.index,
        status = intToSlotStatus(params.status),
        address = dartStringFromCString(params.address),
        privkey = dartListFromCBinaryArray(params.privkey),
        pubkey = dartListFromCBinaryArray(params.pubkey),
        masterPK = dartListFromCBinaryArray(params.masterPK),
        chainCode = dartListFromCBinaryArray(params.chainCode);
}

enum SlotStatus {
  unused,
  sealed,
  unsealed,
  invalid,
}
